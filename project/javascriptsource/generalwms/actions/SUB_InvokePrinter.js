// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
import { Big } from "big.js";
import "mx-global";

// BEGIN EXTRA CODE

// --- Helper Functions ---

// Function to get the HTML content (outerHTML) of elements with a class
const getPrintContentHTML = (className, getAll) => {
    if (!className || className.trim().length === 0) {
        console.warn("getPrintContentHTML: Class name is empty.");
        return null;
    }
    const selector = '.' + className.trim();
    if (getAll) {
        const elements = document.querySelectorAll(selector);
        if (elements.length === 0) {
            console.warn(`getPrintContentHTML: No elements found with class "${className}".`);
            return null;
        }
        // Wrap each element individually. This wrapper is crucial for page break control.
        return [...elements].map(e => `<div class="print-item-wrapper">${e.outerHTML}</div>`).join('');
    } else {
        const element = document.querySelector(selector);
        if (!element) {
            console.warn(`getPrintContentHTML: No element found with class "${className}".`);
            return null;
        }
        // Wrap the single element too
        return `<div class="print-item-wrapper">${element.outerHTML}</div>`;
    }
};

// Function to add print-specific styles
const getPrintStyles = () => {
    return `
        <style>
            @media print {
                @page {
                    /* Adjust size and margin for your specific barcode labels */
                    /* Examples: size: 100mm 50mm; size: 4in 2in; */
                    /* 'auto' lets the browser/printer decide, often based on paper selection */
                    size: auto;
                    /* Minimal margins usually desired for labels */
                    margin: 5mm; /* Adjust as needed, e.g., 0 */
                }

                html, body {
                    margin: 0 !important;
                    padding: 0 !important;
                    width: auto !important; /* Allow natural sizing */
                    height: auto !important;
                    overflow: visible !important; /* Prevent potential clipping by body */
                }

                /* The container for ALL printed content */
                .print-container-temp {
                   /* Ensure it doesn't constrain content */
                   width: auto !important;
                   height: auto !important;
                   overflow: visible !important;
                }

                /* Styles for the wrapper around EACH item being printed (barcode tag) */
                .print-item-wrapper {
                    /* --- KEY CHANGES FOR ONE ITEM PER PAGE --- */
                    page-break-after: always !important; /* Force a page break AFTER each item */
                    /* Use 'break-after: page;' for more modern CSS, but page-break-after has wider compatibility */
                    /* break-after: page !important; */

                    page-break-inside: avoid !important; /* Still useful: Try hard NOT to break WITHIN a single barcode tag */
                    /* break-inside: avoid-page !important; */ /* Modern equivalent */
                    /* --- End KEY CHANGES --- */

                    /* Ensure the wrapper takes up space and content isn't clipped */
                    display: block; /* Make sure it's a block-level element */
                    overflow: visible !important; /* Show all content within the wrapper */
                    width: 100%; /* Make it occupy the available width within page margins */
                    height: auto !important; /* Let content determine height */
                    box-sizing: border-box; /* Include padding/border in element's total width/height */
                    /* Optional: Add padding if you want space between the label edge and the content */
                    /* padding: 2mm; */

                    /* Remove margin, page-break-after handles separation */
                    margin: 0 !important;
                }

                /* Optional: Prevent the very last item from adding an unnecessary blank page */
                /* Note: Browser support/behavior for this might vary */
                 .print-item-wrapper:last-child {
                    page-break-after: avoid !important;
                    /* break-after: avoid !important; */
                 }

                /* Basic styles */
                a, a:visited { text-decoration: none; color: #000; }

                /* Add any other necessary print styles for your barcode tag content */
                /* Example: Ensure barcode images scale correctly */
                .print-item-wrapper img {
                    max-width: 100%;
                    height: auto;
                    display: block; /* Prevents extra space below image */
                }
                /* Example: Ensure text fits */
                .print-item-wrapper p,
                .print-item-wrapper span,
                .print-item-wrapper div {
                   /* Add font size, line height etc. if needed */
                }
            }
        </style>
    `;
};

// --- Global state to prevent concurrent printing issues ---
let isPrinting = false;

// END EXTRA CODE

/**
 * JS_PrintClass Javascript action sends one (the first) or all html elements on the screen that have a given identifier class to the print dialogue. From here, the user can decide to send the result to the printer or save the content as a pdf.
 * @param {string} className - The className is used to detect wich html elements are targeted and should be sent to the print dialog
 * @param {boolean} printsAllOccurances - If printsAllOccurances is set to true, all html elements with the identifier class will be sent to the print dialog. When set to false, the first element will be sent
 * @returns {Promise.<boolean>}
 */
export async function SUB_InvokePrinter(className, printsAllOccurances) {
	// BEGIN USER CODE

    if (isPrinting) {
        console.warn("JS_PrintClass_Printer: Another print operation is already in progress.");
        mx.ui.warning("Printing is already in progress. Please wait.", true); // Notify user
        return false;
    }

    console.log("JS_PrintClass_Printer: Initiating print for class:", className);
    const printContentsRaw = getPrintContentHTML(className, printsAllOccurances);

    if (!printContentsRaw) {
        mx.ui.warning(`Could not find content with class "${className}" to print.`, true); // User-friendly message
        return false;
    }

    isPrinting = true;

    // --- Prepare for printing ---
    const printStyles = getPrintStyles();
    const originalBodyChildren = [];
    // Use documentElement instead of body directly for children sometimes
    const parentElement = document.body || document.documentElement;
    while (parentElement.firstChild) {
        originalBodyChildren.push(parentElement.removeChild(parentElement.firstChild));
    }
    const originalBodyClassName = document.body.className;
    const originalBodyStyle = document.body.getAttribute('style');
    // Also save html attributes like class/style
    const originalHtmlClassName = document.documentElement.className;
    const originalHtmlStyle = document.documentElement.getAttribute('style');


    // --- Define the cleanup/restore function ---
    let restored = false;
    const restoreOriginalBody = () => {
        if (restored) return;
        console.log("JS_PrintClass_Printer: Attempting to restore body...");
        const restoreTarget = document.body || document.documentElement;

        // Clear potentially injected content first
        restoreTarget.innerHTML = '';

        // Restore original classes and styles
        document.body.className = originalBodyClassName;
        if (originalBodyStyle) {
            document.body.setAttribute('style', originalBodyStyle);
        } else {
            document.body.removeAttribute('style');
        }
        document.documentElement.className = originalHtmlClassName;
        if (originalHtmlStyle) {
            document.documentElement.setAttribute('style', originalHtmlStyle);
        } else {
            document.documentElement.removeAttribute('style');
        }

        // Re-append original child nodes
        originalBodyChildren.forEach(node => {
            try {
                restoreTarget.appendChild(node);
            } catch (e) {
                console.error("JS_PrintClass_Printer: Error appending original node during restore:", node, e);
            }
        });

        window.removeEventListener("afterprint", restoreOriginalBody);
        isPrinting = false;
        restored = true;
        console.log("JS_PrintClass_Printer: Body restored.");
    };

    // --- Setup listeners and trigger print ---
    window.addEventListener("afterprint", restoreOriginalBody);
    const fallbackTimeout = setTimeout(() => {
        if (!restored) {
            console.warn("JS_PrintClass_Printer: 'afterprint' event did not fire within timeout, restoring via fallback.");
            restoreOriginalBody();
        }
    }, 3000); // Slightly longer timeout maybe safer

    try {
        // Clear existing body/html styles that might interfere
        document.documentElement.removeAttribute('style');
        document.documentElement.className = '';
        document.body.removeAttribute('style');
        document.body.className = '';

        // Inject styles and wrapped content into a main container within the body
        document.body.innerHTML = `${printStyles}<div class="print-container-temp">${printContentsRaw}</div>`;

        console.log("JS_PrintClass_Printer: Print dialog opening. Each item should be on a separate page.");

        window.print();

    } catch (error) {
        console.error("JS_PrintClass_Printer: Error during print preparation or triggering:", error);
        clearTimeout(fallbackTimeout); // Clear timeout on error
        restoreOriginalBody(); // Attempt restore even on error
        // isPrinting = false; // already set in restoreOriginalBody
        return false;
    } finally {
        // Ensure the timeout is cleared if printing finished normally before the timeout
        // Note: The 'afterprint' handler *should* clear it, but this adds a layer of safety.
        // Actually, don't clear here - print() is async, the timeout needs to run *after* print dialog closes.
        // The afterprint listener and the timeout itself handle the clearing correctly.
    }

    return true;
	// END USER CODE
}
