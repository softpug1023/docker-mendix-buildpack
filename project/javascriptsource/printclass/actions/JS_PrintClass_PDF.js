// This file was generated by Mendix Studio Pro.
//
// WARNING: Only the following code will be retained when actions are regenerated:
// - the import list
// - the code between BEGIN USER CODE and END USER CODE
// - the code between BEGIN EXTRA CODE and END EXTRA CODE
// Other code you write will be lost the next time you deploy the project.
import { Big } from "big.js";
import "mx-global";
import { jsPDF } from "jspdf";

// BEGIN EXTRA CODE
const getFirstWithClass = (className) => {
	const element = document.querySelector('.' + className);
	if (!element) {
		return;
	}
	return element.innerHTML;
}

const getAllWithClass = (className) => {
	const elements = document.querySelectorAll('.' + className);
	if (elements.length === 0) {
		return;
	}
	return [...elements].map(e => '<div>' + e.innerHTML + '</div>').join('');
}

const storeFile = (file, blob) => {
	return new Promise((resolve, reject) => {
		const guid = file.getGuid();
		const filename = file.get("Name");
		const onSuccess = () => resolve(true);
		const onError = (error) => reject(error.message);
		mx.data.saveDocument(guid, filename, {}, blob, onSuccess, onError);
	});
}

const getMargins = (margins) => {
	const marginArray = margins.split(" ");
	switch (marginArray.length) {
		case 1:
			return [
				parseInt(marginArray[0]),
				parseInt(marginArray[0]),
				parseInt(marginArray[0]),
				parseInt(marginArray[0])
			];
		case 2:
			return [
				parseInt(marginArray[0]),
				parseInt(marginArray[1]),
				parseInt(marginArray[0]),
				parseInt(marginArray[1])
			];
		case 3:
			return [
				parseInt(marginArray[0]),
				parseInt(marginArray[1]),
				parseInt(marginArray[1]),
				parseInt(marginArray[2])
			];
		case 4:
			return [
				parseInt(marginArray[0]),
				parseInt(marginArray[1]),
				parseInt(marginArray[2]),
				parseInt(marginArray[3])
			];
		default:
			return [1.5, 1.5, 1.5, 1.5];
			
	}


}
// END EXTRA CODE

/**
 * JS_PrintClass Javascript action sends one (the first) or all html elements on the screen that have a given identifier class to the print dialogue. From here, the user can decide to send the result to the printer or save the content as a pdf.
 * @param {string} className - The className is used to detect wich html elements are targeted and should be sent to the print dialog
 * @param {boolean} printsAllOccurances - If printsAllOccurances is set to true, all html elements with the identifier class will be sent to the print dialog. When set to false, the first element will be sent
 * @param {MxObject} pDFDocument - FileDocument to save the data to
 * @param {string} margins - Margins in cm to add. For example:
"1 2 3 4" (top, bottom, left right)
"1 2 3" (top, left and right, bottom)
"1 2" (top and bottom, left and right)
"1" (all margins)

Default value is 1.5 cm
 * @param {Big} zoom - Zoom factor. Default value is 100
 * @returns {Promise.<boolean>}
 */
export async function JS_PrintClass_PDF(className, printsAllOccurances, pDFDocument, margins, zoom) {
	// BEGIN USER CODE
	if (!className || 0 === className.length) {
		return;
	}

	const printContents = printsAllOccurances 
		? getAllWithClass(className)
		: getFirstWithClass(className);

	if (!printContents) {
		return false;
	}

	const doc = new jsPDF({
		unit: "cm"
	});
	
	try {
		const result = await new Promise((resolve, reject) => {
			doc.html(printContents, {
				callback: (doc) => {
					const blob = doc.output("blob");
					storeFile(pDFDocument, blob)
						.then(() => resolve(true))
						.catch((error) => reject(error));
				},
				width: zoom && zoom > 0 ? 21 * zoom / 100 : 21,
				windowWidth: window.innerWidth,
				margin: getMargins(margins),
			});
		});
		return result;
	} catch(error) {
		console.error("Error in JS_PrintClass_PDF: ", error);
		return false;
	}

	// END USER CODE
}
